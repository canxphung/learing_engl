// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               unknown
// source: auth/auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Status, StatusResponse } from "../common/common";

export const protobufPackage = "auth";

/** Authentication request with email and password */
export interface LoginRequest {
  email: string;
  password: string;
  /** Optional device identifier */
  deviceId: string;
  /** Optional device name */
  deviceName: string;
}

/** Authentication response with tokens */
export interface LoginResponse {
  status: Status | undefined;
  accessToken: string;
  refreshToken: string;
  /** Token expiration time in seconds */
  expiresIn: string;
  /** e.g., "Bearer" */
  tokenType: string;
  user: UserInfo | undefined;
}

/** User registration request */
export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
  level: string;
  goals: string[];
}

/** Registration response */
export interface RegisterResponse {
  status: Status | undefined;
  userId: string;
  /** For email verification */
  verificationToken: string;
}

/** Refresh token request */
export interface RefreshTokenRequest {
  refreshToken: string;
}

/** Refresh token response */
export interface RefreshTokenResponse {
  status: Status | undefined;
  accessToken: string;
  refreshToken: string;
  expiresIn: string;
}

/** Logout request */
export interface LogoutRequest {
  accessToken: string;
  refreshToken: string;
  /** Logout from all devices */
  logoutAllDevices: boolean;
}

/** Password reset request */
export interface ForgotPasswordRequest {
  email: string;
}

/** Password reset response */
export interface ForgotPasswordResponse {
  status: Status | undefined;
  resetToken: string;
}

/** Reset password with token */
export interface ResetPasswordRequest {
  resetToken: string;
  newPassword: string;
}

/** Verify token request */
export interface VerifyTokenRequest {
  token: string;
}

/** Verify token response */
export interface VerifyTokenResponse {
  status: Status | undefined;
  valid: boolean;
  user: UserInfo | undefined;
  expiresAt: string;
}

/** Change password request (for authenticated users) */
export interface ChangePasswordRequest {
  oldPassword: string;
  newPassword: string;
}

/** Email verification request */
export interface VerifyEmailRequest {
  verificationToken: string;
}

/** Resend verification email */
export interface ResendVerificationRequest {
  email: string;
}

/** User information returned in auth responses */
export interface UserInfo {
  id: string;
  email: string;
  name: string;
  level: string;
  roles: string[];
  permissions: string[];
  emailVerified: boolean;
}

/** OAuth2 authentication request */
export interface OAuthLoginRequest {
  /** google, facebook, github, etc. */
  provider: string;
  /** Authorization code */
  code: string;
  redirectUri: string;
  state: string;
}

/** OAuth2 authentication response */
export interface OAuthLoginResponse {
  status: Status | undefined;
  accessToken: string;
  refreshToken: string;
  expiresIn: string;
  user:
    | UserInfo
    | undefined;
  /** True if user was just created */
  isNewUser: boolean;
}

/** Two-factor authentication setup request */
export interface Setup2FARequest {
  userId: string;
}

/** Two-factor authentication setup response */
export interface Setup2FAResponse {
  status:
    | Status
    | undefined;
  /** Secret key for TOTP */
  secret: string;
  /** QR code URL for scanning */
  qrCodeUrl: string;
  backupCodes: string[];
}

/** Two-factor authentication verification */
export interface Verify2FARequest {
  userId: string;
  /** 6-digit TOTP code */
  code: string;
}

/** Two-factor authentication disable request */
export interface Disable2FARequest {
  userId: string;
  password: string;
}

/** Session information */
export interface Session {
  id: string;
  userId: string;
  deviceId: string;
  deviceName: string;
  ipAddress: string;
  userAgent: string;
  createdAt: string;
  lastActivity: string;
  isActive: boolean;
}

/** List active sessions request */
export interface ListSessionsRequest {
  userId: string;
}

/** List active sessions response */
export interface ListSessionsResponse {
  status: Status | undefined;
  sessions: Session[];
}

/** Revoke session request */
export interface RevokeSessionRequest {
  sessionId: string;
}

/** Check permission request */
export interface CheckPermissionRequest {
  userId: string;
  resource: string;
  /** read, write, delete, etc. */
  action: string;
}

/** Check permission response */
export interface CheckPermissionResponse {
  status: Status | undefined;
  allowed: boolean;
  reason: string;
}

function createBaseLoginRequest(): LoginRequest {
  return { email: "", password: "", deviceId: "", deviceName: "" };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(message: LoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.deviceId !== "") {
      writer.uint32(26).string(message.deviceId);
    }
    if (message.deviceName !== "") {
      writer.uint32(34).string(message.deviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.deviceName !== "") {
      obj.deviceName = message.deviceName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.deviceId = object.deviceId ?? "";
    message.deviceName = object.deviceName ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { status: undefined, accessToken: "", refreshToken: "", expiresIn: "0", tokenType: "", user: undefined };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(message: LoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.expiresIn !== "0") {
      writer.uint32(32).int64(message.expiresIn);
    }
    if (message.tokenType !== "") {
      writer.uint32(42).string(message.tokenType);
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiresIn = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      expiresIn: isSet(object.expiresIn) ? globalThis.String(object.expiresIn) : "0",
      tokenType: isSet(object.tokenType) ? globalThis.String(object.tokenType) : "",
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.expiresIn !== "0") {
      obj.expiresIn = message.expiresIn;
    }
    if (message.tokenType !== "") {
      obj.tokenType = message.tokenType;
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.expiresIn = object.expiresIn ?? "0";
    message.tokenType = object.tokenType ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseRegisterRequest(): RegisterRequest {
  return { email: "", password: "", name: "", level: "", goals: [] };
}

export const RegisterRequest: MessageFns<RegisterRequest> = {
  encode(message: RegisterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.level !== "") {
      writer.uint32(34).string(message.level);
    }
    for (const v of message.goals) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.level = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.goals.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      goals: globalThis.Array.isArray(object?.goals) ? object.goals.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RegisterRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.goals?.length) {
      obj.goals = message.goals;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterRequest>, I>>(base?: I): RegisterRequest {
    return RegisterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterRequest>, I>>(object: I): RegisterRequest {
    const message = createBaseRegisterRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.name = object.name ?? "";
    message.level = object.level ?? "";
    message.goals = object.goals?.map((e) => e) || [];
    return message;
  },
};

function createBaseRegisterResponse(): RegisterResponse {
  return { status: undefined, userId: "", verificationToken: "" };
}

export const RegisterResponse: MessageFns<RegisterResponse> = {
  encode(message: RegisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.verificationToken !== "") {
      writer.uint32(26).string(message.verificationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verificationToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      verificationToken: isSet(object.verificationToken) ? globalThis.String(object.verificationToken) : "",
    };
  },

  toJSON(message: RegisterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.verificationToken !== "") {
      obj.verificationToken = message.verificationToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterResponse>, I>>(base?: I): RegisterResponse {
    return RegisterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterResponse>, I>>(object: I): RegisterResponse {
    const message = createBaseRegisterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.userId = object.userId ?? "";
    message.verificationToken = object.verificationToken ?? "";
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return { status: undefined, accessToken: "", refreshToken: "", expiresIn: "0" };
}

export const RefreshTokenResponse: MessageFns<RefreshTokenResponse> = {
  encode(message: RefreshTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.expiresIn !== "0") {
      writer.uint32(32).int64(message.expiresIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiresIn = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      expiresIn: isSet(object.expiresIn) ? globalThis.String(object.expiresIn) : "0",
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.expiresIn !== "0") {
      obj.expiresIn = message.expiresIn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(base?: I): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(object: I): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.expiresIn = object.expiresIn ?? "0";
    return message;
  },
};

function createBaseLogoutRequest(): LogoutRequest {
  return { accessToken: "", refreshToken: "", logoutAllDevices: false };
}

export const LogoutRequest: MessageFns<LogoutRequest> = {
  encode(message: LogoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.logoutAllDevices !== false) {
      writer.uint32(24).bool(message.logoutAllDevices);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.logoutAllDevices = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      logoutAllDevices: isSet(object.logoutAllDevices) ? globalThis.Boolean(object.logoutAllDevices) : false,
    };
  },

  toJSON(message: LogoutRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.logoutAllDevices !== false) {
      obj.logoutAllDevices = message.logoutAllDevices;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutRequest>, I>>(base?: I): LogoutRequest {
    return LogoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutRequest>, I>>(object: I): LogoutRequest {
    const message = createBaseLogoutRequest();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.logoutAllDevices = object.logoutAllDevices ?? false;
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { status: undefined, resetToken: "" };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.resetToken !== "") {
      writer.uint32(18).string(message.resetToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resetToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      resetToken: isSet(object.resetToken) ? globalThis.String(object.resetToken) : "",
    };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.resetToken !== "") {
      obj.resetToken = message.resetToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(base?: I): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(object: I): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.resetToken = object.resetToken ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { resetToken: "", newPassword: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resetToken !== "") {
      writer.uint32(10).string(message.resetToken);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resetToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      resetToken: isSet(object.resetToken) ? globalThis.String(object.resetToken) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.resetToken !== "") {
      obj.resetToken = message.resetToken;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.resetToken = object.resetToken ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseVerifyTokenRequest(): VerifyTokenRequest {
  return { token: "" };
}

export const VerifyTokenRequest: MessageFns<VerifyTokenRequest> = {
  encode(message: VerifyTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyTokenRequest {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: VerifyTokenRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyTokenRequest>, I>>(base?: I): VerifyTokenRequest {
    return VerifyTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyTokenRequest>, I>>(object: I): VerifyTokenRequest {
    const message = createBaseVerifyTokenRequest();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseVerifyTokenResponse(): VerifyTokenResponse {
  return { status: undefined, valid: false, user: undefined, expiresAt: "0" };
}

export const VerifyTokenResponse: MessageFns<VerifyTokenResponse> = {
  encode(message: VerifyTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.valid !== false) {
      writer.uint32(16).bool(message.valid);
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(26).fork()).join();
    }
    if (message.expiresAt !== "0") {
      writer.uint32(32).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiresAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyTokenResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
      expiresAt: isSet(object.expiresAt) ? globalThis.String(object.expiresAt) : "0",
    };
  },

  toJSON(message: VerifyTokenResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    if (message.expiresAt !== "0") {
      obj.expiresAt = message.expiresAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyTokenResponse>, I>>(base?: I): VerifyTokenResponse {
    return VerifyTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyTokenResponse>, I>>(object: I): VerifyTokenResponse {
    const message = createBaseVerifyTokenResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.valid = object.valid ?? false;
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    message.expiresAt = object.expiresAt ?? "0";
    return message;
  },
};

function createBaseChangePasswordRequest(): ChangePasswordRequest {
  return { oldPassword: "", newPassword: "" };
}

export const ChangePasswordRequest: MessageFns<ChangePasswordRequest> = {
  encode(message: ChangePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oldPassword !== "") {
      writer.uint32(10).string(message.oldPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordRequest {
    return {
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ChangePasswordRequest): unknown {
    const obj: any = {};
    if (message.oldPassword !== "") {
      obj.oldPassword = message.oldPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(base?: I): ChangePasswordRequest {
    return ChangePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(object: I): ChangePasswordRequest {
    const message = createBaseChangePasswordRequest();
    message.oldPassword = object.oldPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseVerifyEmailRequest(): VerifyEmailRequest {
  return { verificationToken: "" };
}

export const VerifyEmailRequest: MessageFns<VerifyEmailRequest> = {
  encode(message: VerifyEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.verificationToken !== "") {
      writer.uint32(10).string(message.verificationToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.verificationToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyEmailRequest {
    return { verificationToken: isSet(object.verificationToken) ? globalThis.String(object.verificationToken) : "" };
  },

  toJSON(message: VerifyEmailRequest): unknown {
    const obj: any = {};
    if (message.verificationToken !== "") {
      obj.verificationToken = message.verificationToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyEmailRequest>, I>>(base?: I): VerifyEmailRequest {
    return VerifyEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyEmailRequest>, I>>(object: I): VerifyEmailRequest {
    const message = createBaseVerifyEmailRequest();
    message.verificationToken = object.verificationToken ?? "";
    return message;
  },
};

function createBaseResendVerificationRequest(): ResendVerificationRequest {
  return { email: "" };
}

export const ResendVerificationRequest: MessageFns<ResendVerificationRequest> = {
  encode(message: ResendVerificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendVerificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendVerificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResendVerificationRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ResendVerificationRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResendVerificationRequest>, I>>(base?: I): ResendVerificationRequest {
    return ResendVerificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResendVerificationRequest>, I>>(object: I): ResendVerificationRequest {
    const message = createBaseResendVerificationRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { id: "", email: "", name: "", level: "", roles: [], permissions: [], emailVerified: false };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.level !== "") {
      writer.uint32(34).string(message.level);
    }
    for (const v of message.roles) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.permissions) {
      writer.uint32(50).string(v!);
    }
    if (message.emailVerified !== false) {
      writer.uint32(56).bool(message.emailVerified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.level = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.emailVerified = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => globalThis.String(e)) : [],
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => globalThis.String(e))
        : [],
      emailVerified: isSet(object.emailVerified) ? globalThis.Boolean(object.emailVerified) : false,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions;
    }
    if (message.emailVerified !== false) {
      obj.emailVerified = message.emailVerified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.id = object.id ?? "";
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    message.level = object.level ?? "";
    message.roles = object.roles?.map((e) => e) || [];
    message.permissions = object.permissions?.map((e) => e) || [];
    message.emailVerified = object.emailVerified ?? false;
    return message;
  },
};

function createBaseOAuthLoginRequest(): OAuthLoginRequest {
  return { provider: "", code: "", redirectUri: "", state: "" };
}

export const OAuthLoginRequest: MessageFns<OAuthLoginRequest> = {
  encode(message: OAuthLoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.redirectUri !== "") {
      writer.uint32(26).string(message.redirectUri);
    }
    if (message.state !== "") {
      writer.uint32(34).string(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthLoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.state = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthLoginRequest {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
    };
  },

  toJSON(message: OAuthLoginRequest): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthLoginRequest>, I>>(base?: I): OAuthLoginRequest {
    return OAuthLoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthLoginRequest>, I>>(object: I): OAuthLoginRequest {
    const message = createBaseOAuthLoginRequest();
    message.provider = object.provider ?? "";
    message.code = object.code ?? "";
    message.redirectUri = object.redirectUri ?? "";
    message.state = object.state ?? "";
    return message;
  },
};

function createBaseOAuthLoginResponse(): OAuthLoginResponse {
  return { status: undefined, accessToken: "", refreshToken: "", expiresIn: "0", user: undefined, isNewUser: false };
}

export const OAuthLoginResponse: MessageFns<OAuthLoginResponse> = {
  encode(message: OAuthLoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.expiresIn !== "0") {
      writer.uint32(32).int64(message.expiresIn);
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.isNewUser !== false) {
      writer.uint32(48).bool(message.isNewUser);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthLoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiresIn = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isNewUser = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthLoginResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      expiresIn: isSet(object.expiresIn) ? globalThis.String(object.expiresIn) : "0",
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
      isNewUser: isSet(object.isNewUser) ? globalThis.Boolean(object.isNewUser) : false,
    };
  },

  toJSON(message: OAuthLoginResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.expiresIn !== "0") {
      obj.expiresIn = message.expiresIn;
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    if (message.isNewUser !== false) {
      obj.isNewUser = message.isNewUser;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthLoginResponse>, I>>(base?: I): OAuthLoginResponse {
    return OAuthLoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthLoginResponse>, I>>(object: I): OAuthLoginResponse {
    const message = createBaseOAuthLoginResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.expiresIn = object.expiresIn ?? "0";
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    message.isNewUser = object.isNewUser ?? false;
    return message;
  },
};

function createBaseSetup2FARequest(): Setup2FARequest {
  return { userId: "" };
}

export const Setup2FARequest: MessageFns<Setup2FARequest> = {
  encode(message: Setup2FARequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Setup2FARequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetup2FARequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Setup2FARequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: Setup2FARequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Setup2FARequest>, I>>(base?: I): Setup2FARequest {
    return Setup2FARequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Setup2FARequest>, I>>(object: I): Setup2FARequest {
    const message = createBaseSetup2FARequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseSetup2FAResponse(): Setup2FAResponse {
  return { status: undefined, secret: "", qrCodeUrl: "", backupCodes: [] };
}

export const Setup2FAResponse: MessageFns<Setup2FAResponse> = {
  encode(message: Setup2FAResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.secret !== "") {
      writer.uint32(18).string(message.secret);
    }
    if (message.qrCodeUrl !== "") {
      writer.uint32(26).string(message.qrCodeUrl);
    }
    for (const v of message.backupCodes) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Setup2FAResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetup2FAResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secret = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.qrCodeUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.backupCodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Setup2FAResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      secret: isSet(object.secret) ? globalThis.String(object.secret) : "",
      qrCodeUrl: isSet(object.qrCodeUrl) ? globalThis.String(object.qrCodeUrl) : "",
      backupCodes: globalThis.Array.isArray(object?.backupCodes)
        ? object.backupCodes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Setup2FAResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.secret !== "") {
      obj.secret = message.secret;
    }
    if (message.qrCodeUrl !== "") {
      obj.qrCodeUrl = message.qrCodeUrl;
    }
    if (message.backupCodes?.length) {
      obj.backupCodes = message.backupCodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Setup2FAResponse>, I>>(base?: I): Setup2FAResponse {
    return Setup2FAResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Setup2FAResponse>, I>>(object: I): Setup2FAResponse {
    const message = createBaseSetup2FAResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.secret = object.secret ?? "";
    message.qrCodeUrl = object.qrCodeUrl ?? "";
    message.backupCodes = object.backupCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseVerify2FARequest(): Verify2FARequest {
  return { userId: "", code: "" };
}

export const Verify2FARequest: MessageFns<Verify2FARequest> = {
  encode(message: Verify2FARequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Verify2FARequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerify2FARequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Verify2FARequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: Verify2FARequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Verify2FARequest>, I>>(base?: I): Verify2FARequest {
    return Verify2FARequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Verify2FARequest>, I>>(object: I): Verify2FARequest {
    const message = createBaseVerify2FARequest();
    message.userId = object.userId ?? "";
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseDisable2FARequest(): Disable2FARequest {
  return { userId: "", password: "" };
}

export const Disable2FARequest: MessageFns<Disable2FARequest> = {
  encode(message: Disable2FARequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Disable2FARequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisable2FARequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Disable2FARequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: Disable2FARequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Disable2FARequest>, I>>(base?: I): Disable2FARequest {
    return Disable2FARequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Disable2FARequest>, I>>(object: I): Disable2FARequest {
    const message = createBaseDisable2FARequest();
    message.userId = object.userId ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseSession(): Session {
  return {
    id: "",
    userId: "",
    deviceId: "",
    deviceName: "",
    ipAddress: "",
    userAgent: "",
    createdAt: "",
    lastActivity: "",
    isActive: false,
  };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.deviceId !== "") {
      writer.uint32(26).string(message.deviceId);
    }
    if (message.deviceName !== "") {
      writer.uint32(34).string(message.deviceName);
    }
    if (message.ipAddress !== "") {
      writer.uint32(42).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(50).string(message.userAgent);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.lastActivity !== "") {
      writer.uint32(66).string(message.lastActivity);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lastActivity = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      lastActivity: isSet(object.lastActivity) ? globalThis.String(object.lastActivity) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.deviceName !== "") {
      obj.deviceName = message.deviceName;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.lastActivity !== "") {
      obj.lastActivity = message.lastActivity;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.deviceId = object.deviceId ?? "";
    message.deviceName = object.deviceName ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.userAgent = object.userAgent ?? "";
    message.createdAt = object.createdAt ?? "";
    message.lastActivity = object.lastActivity ?? "";
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseListSessionsRequest(): ListSessionsRequest {
  return { userId: "" };
}

export const ListSessionsRequest: MessageFns<ListSessionsRequest> = {
  encode(message: ListSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: ListSessionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(base?: I): ListSessionsRequest {
    return ListSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(object: I): ListSessionsRequest {
    const message = createBaseListSessionsRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseListSessionsResponse(): ListSessionsResponse {
  return { status: undefined, sessions: [] };
}

export const ListSessionsResponse: MessageFns<ListSessionsResponse> = {
  encode(message: ListSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      sessions: globalThis.Array.isArray(object?.sessions) ? object.sessions.map((e: any) => Session.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListSessionsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => Session.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(base?: I): ListSessionsResponse {
    return ListSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(object: I): ListSessionsResponse {
    const message = createBaseListSessionsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRevokeSessionRequest(): RevokeSessionRequest {
  return { sessionId: "" };
}

export const RevokeSessionRequest: MessageFns<RevokeSessionRequest> = {
  encode(message: RevokeSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: RevokeSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(base?: I): RevokeSessionRequest {
    return RevokeSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(object: I): RevokeSessionRequest {
    const message = createBaseRevokeSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseCheckPermissionRequest(): CheckPermissionRequest {
  return { userId: "", resource: "", action: "" };
}

export const CheckPermissionRequest: MessageFns<CheckPermissionRequest> = {
  encode(message: CheckPermissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.resource !== "") {
      writer.uint32(18).string(message.resource);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckPermissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckPermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckPermissionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: CheckPermissionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckPermissionRequest>, I>>(base?: I): CheckPermissionRequest {
    return CheckPermissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckPermissionRequest>, I>>(object: I): CheckPermissionRequest {
    const message = createBaseCheckPermissionRequest();
    message.userId = object.userId ?? "";
    message.resource = object.resource ?? "";
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseCheckPermissionResponse(): CheckPermissionResponse {
  return { status: undefined, allowed: false, reason: "" };
}

export const CheckPermissionResponse: MessageFns<CheckPermissionResponse> = {
  encode(message: CheckPermissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.allowed !== false) {
      writer.uint32(16).bool(message.allowed);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckPermissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckPermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allowed = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckPermissionResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      allowed: isSet(object.allowed) ? globalThis.Boolean(object.allowed) : false,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: CheckPermissionResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.allowed !== false) {
      obj.allowed = message.allowed;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckPermissionResponse>, I>>(base?: I): CheckPermissionResponse {
    return CheckPermissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckPermissionResponse>, I>>(object: I): CheckPermissionResponse {
    const message = createBaseCheckPermissionResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.allowed = object.allowed ?? false;
    message.reason = object.reason ?? "";
    return message;
  },
};

/** Authentication service definition */
export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  /** User login */
  login: {
    path: "/auth.AuthService/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest): Buffer => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginRequest => LoginRequest.decode(value),
    responseSerialize: (value: LoginResponse): Buffer => Buffer.from(LoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginResponse => LoginResponse.decode(value),
  },
  /** User registration */
  register: {
    path: "/auth.AuthService/Register",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterRequest): Buffer => Buffer.from(RegisterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RegisterRequest => RegisterRequest.decode(value),
    responseSerialize: (value: RegisterResponse): Buffer => Buffer.from(RegisterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RegisterResponse => RegisterResponse.decode(value),
  },
  /** Refresh access token */
  refreshToken: {
    path: "/auth.AuthService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: RefreshTokenResponse): Buffer =>
      Buffer.from(RefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RefreshTokenResponse => RefreshTokenResponse.decode(value),
  },
  /** User logout */
  logout: {
    path: "/auth.AuthService/Logout",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LogoutRequest): Buffer => Buffer.from(LogoutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LogoutRequest => LogoutRequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  /** Request password reset */
  forgotPassword: {
    path: "/auth.AuthService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest): Buffer =>
      Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ForgotPasswordRequest => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse): Buffer =>
      Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ForgotPasswordResponse => ForgotPasswordResponse.decode(value),
  },
  /** Reset password with token */
  resetPassword: {
    path: "/auth.AuthService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest): Buffer => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResetPasswordRequest => ResetPasswordRequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  /** Verify access token */
  verifyToken: {
    path: "/auth.AuthService/VerifyToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyTokenRequest): Buffer => Buffer.from(VerifyTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyTokenRequest => VerifyTokenRequest.decode(value),
    responseSerialize: (value: VerifyTokenResponse): Buffer => Buffer.from(VerifyTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyTokenResponse => VerifyTokenResponse.decode(value),
  },
  /** Change password (authenticated) */
  changePassword: {
    path: "/auth.AuthService/ChangePassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangePasswordRequest): Buffer =>
      Buffer.from(ChangePasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ChangePasswordRequest => ChangePasswordRequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  /** Verify email address */
  verifyEmail: {
    path: "/auth.AuthService/VerifyEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyEmailRequest): Buffer => Buffer.from(VerifyEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyEmailRequest => VerifyEmailRequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  /** Resend verification email */
  resendVerification: {
    path: "/auth.AuthService/ResendVerification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResendVerificationRequest): Buffer =>
      Buffer.from(ResendVerificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResendVerificationRequest => ResendVerificationRequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  /** OAuth login */
  oAuthLogin: {
    path: "/auth.AuthService/OAuthLogin",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OAuthLoginRequest): Buffer => Buffer.from(OAuthLoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OAuthLoginRequest => OAuthLoginRequest.decode(value),
    responseSerialize: (value: OAuthLoginResponse): Buffer => Buffer.from(OAuthLoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OAuthLoginResponse => OAuthLoginResponse.decode(value),
  },
  /** Setup two-factor authentication */
  setup2Fa: {
    path: "/auth.AuthService/Setup2FA",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Setup2FARequest): Buffer => Buffer.from(Setup2FARequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): Setup2FARequest => Setup2FARequest.decode(value),
    responseSerialize: (value: Setup2FAResponse): Buffer => Buffer.from(Setup2FAResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): Setup2FAResponse => Setup2FAResponse.decode(value),
  },
  /** Verify two-factor authentication code */
  verify2Fa: {
    path: "/auth.AuthService/Verify2FA",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Verify2FARequest): Buffer => Buffer.from(Verify2FARequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): Verify2FARequest => Verify2FARequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  /** Disable two-factor authentication */
  disable2Fa: {
    path: "/auth.AuthService/Disable2FA",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Disable2FARequest): Buffer => Buffer.from(Disable2FARequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): Disable2FARequest => Disable2FARequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  /** List active sessions */
  listSessions: {
    path: "/auth.AuthService/ListSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSessionsRequest): Buffer => Buffer.from(ListSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSessionsRequest => ListSessionsRequest.decode(value),
    responseSerialize: (value: ListSessionsResponse): Buffer =>
      Buffer.from(ListSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSessionsResponse => ListSessionsResponse.decode(value),
  },
  /** Revoke a session */
  revokeSession: {
    path: "/auth.AuthService/RevokeSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevokeSessionRequest): Buffer => Buffer.from(RevokeSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RevokeSessionRequest => RevokeSessionRequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  /** Check user permission */
  checkPermission: {
    path: "/auth.AuthService/CheckPermission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckPermissionRequest): Buffer =>
      Buffer.from(CheckPermissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckPermissionRequest => CheckPermissionRequest.decode(value),
    responseSerialize: (value: CheckPermissionResponse): Buffer =>
      Buffer.from(CheckPermissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckPermissionResponse => CheckPermissionResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  /** User login */
  login: handleUnaryCall<LoginRequest, LoginResponse>;
  /** User registration */
  register: handleUnaryCall<RegisterRequest, RegisterResponse>;
  /** Refresh access token */
  refreshToken: handleUnaryCall<RefreshTokenRequest, RefreshTokenResponse>;
  /** User logout */
  logout: handleUnaryCall<LogoutRequest, StatusResponse>;
  /** Request password reset */
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  /** Reset password with token */
  resetPassword: handleUnaryCall<ResetPasswordRequest, StatusResponse>;
  /** Verify access token */
  verifyToken: handleUnaryCall<VerifyTokenRequest, VerifyTokenResponse>;
  /** Change password (authenticated) */
  changePassword: handleUnaryCall<ChangePasswordRequest, StatusResponse>;
  /** Verify email address */
  verifyEmail: handleUnaryCall<VerifyEmailRequest, StatusResponse>;
  /** Resend verification email */
  resendVerification: handleUnaryCall<ResendVerificationRequest, StatusResponse>;
  /** OAuth login */
  oAuthLogin: handleUnaryCall<OAuthLoginRequest, OAuthLoginResponse>;
  /** Setup two-factor authentication */
  setup2Fa: handleUnaryCall<Setup2FARequest, Setup2FAResponse>;
  /** Verify two-factor authentication code */
  verify2Fa: handleUnaryCall<Verify2FARequest, StatusResponse>;
  /** Disable two-factor authentication */
  disable2Fa: handleUnaryCall<Disable2FARequest, StatusResponse>;
  /** List active sessions */
  listSessions: handleUnaryCall<ListSessionsRequest, ListSessionsResponse>;
  /** Revoke a session */
  revokeSession: handleUnaryCall<RevokeSessionRequest, StatusResponse>;
  /** Check user permission */
  checkPermission: handleUnaryCall<CheckPermissionRequest, CheckPermissionResponse>;
}

export interface AuthServiceClient extends Client {
  /** User login */
  login(
    request: LoginRequest,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  /** User registration */
  register(
    request: RegisterRequest,
    callback: (error: ServiceError | null, response: RegisterResponse) => void,
  ): ClientUnaryCall;
  register(
    request: RegisterRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterResponse) => void,
  ): ClientUnaryCall;
  register(
    request: RegisterRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterResponse) => void,
  ): ClientUnaryCall;
  /** Refresh access token */
  refreshToken(
    request: RefreshTokenRequest,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefreshTokenResponse) => void,
  ): ClientUnaryCall;
  /** User logout */
  logout(
    request: LogoutRequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  logout(
    request: LogoutRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  logout(
    request: LogoutRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  /** Request password reset */
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  /** Reset password with token */
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  /** Verify access token */
  verifyToken(
    request: VerifyTokenRequest,
    callback: (error: ServiceError | null, response: VerifyTokenResponse) => void,
  ): ClientUnaryCall;
  verifyToken(
    request: VerifyTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyTokenResponse) => void,
  ): ClientUnaryCall;
  verifyToken(
    request: VerifyTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyTokenResponse) => void,
  ): ClientUnaryCall;
  /** Change password (authenticated) */
  changePassword(
    request: ChangePasswordRequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  /** Verify email address */
  verifyEmail(
    request: VerifyEmailRequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  verifyEmail(
    request: VerifyEmailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  verifyEmail(
    request: VerifyEmailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  /** Resend verification email */
  resendVerification(
    request: ResendVerificationRequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  resendVerification(
    request: ResendVerificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  resendVerification(
    request: ResendVerificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  /** OAuth login */
  oAuthLogin(
    request: OAuthLoginRequest,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  oAuthLogin(
    request: OAuthLoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  oAuthLogin(
    request: OAuthLoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OAuthLoginResponse) => void,
  ): ClientUnaryCall;
  /** Setup two-factor authentication */
  setup2Fa(
    request: Setup2FARequest,
    callback: (error: ServiceError | null, response: Setup2FAResponse) => void,
  ): ClientUnaryCall;
  setup2Fa(
    request: Setup2FARequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Setup2FAResponse) => void,
  ): ClientUnaryCall;
  setup2Fa(
    request: Setup2FARequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Setup2FAResponse) => void,
  ): ClientUnaryCall;
  /** Verify two-factor authentication code */
  verify2Fa(
    request: Verify2FARequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  verify2Fa(
    request: Verify2FARequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  verify2Fa(
    request: Verify2FARequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  /** Disable two-factor authentication */
  disable2Fa(
    request: Disable2FARequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  disable2Fa(
    request: Disable2FARequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  disable2Fa(
    request: Disable2FARequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  /** List active sessions */
  listSessions(
    request: ListSessionsRequest,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  /** Revoke a session */
  revokeSession(
    request: RevokeSessionRequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  revokeSession(
    request: RevokeSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  revokeSession(
    request: RevokeSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  /** Check user permission */
  checkPermission(
    request: CheckPermissionRequest,
    callback: (error: ServiceError | null, response: CheckPermissionResponse) => void,
  ): ClientUnaryCall;
  checkPermission(
    request: CheckPermissionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckPermissionResponse) => void,
  ): ClientUnaryCall;
  checkPermission(
    request: CheckPermissionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckPermissionResponse) => void,
  ): ClientUnaryCall;
}

export const AuthServiceClient = makeGenericClientConstructor(AuthServiceService, "auth.AuthService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthServiceClient;
  service: typeof AuthServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
